# toolkit/vulnerability_scanner.py
import requests
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from typing import List

DEFAULT_TIMEOUT = 8

SQL_ERROR_SIGNS: List[str] = [
    "sql syntax", "mysql", "syntax to use near", "unclosed quotation mark",
    "quoted string not properly terminated", "odbc", "pdo", "sqlstate", "database error",
    "mysql_fetch", "num_rows", "syntax error"
]

def _replace_query_param(url: str, param: str, new_value: str) -> str:
    p = urlparse(url)
    qs = parse_qs(p.query, keep_blank_values=True)
    qs[param] = [new_value]
    new_query = urlencode(qs, doseq=True)
    new_parts = (p.scheme, p.netloc, p.path, p.params, new_query, p.fragment)
    return urlunparse(new_parts)

def _safe_get(url: str, timeout: int = DEFAULT_TIMEOUT) -> requests.Response:
    return requests.get(url, timeout=timeout, allow_redirects=True, headers={"User-Agent": "Toolkit/1.0"})

def test_sql_injection(url: str, param: str) -> bool:
    """
    Basic SQLi tests:
    1) inject common boolean payloads and look for significant change in response length vs baseline
    2) inject error-triggering payloads and search for SQL error signatures
    Returns True if any heuristic indicates SQLi.
    """
    try:
        baseline_resp = _safe_get(url)
        baseline = baseline_resp.text.lower()
    except Exception:
        baseline = ""

    # payloads: boolean and error-triggering
    payloads = [
        "' OR '1'='1",
        "\" OR \"1\"=\"1",
        "' OR 1=1 -- ",
        "'\" OR '\"'='\"",
        "'; -- ",
        "\"; -- ",
    ]

    for pl in payloads:
        test_url = _replace_query_param(url, param, pl)
        try:
            resp = _safe_get(test_url)
        except requests.RequestException:
            continue

        body = resp.text.lower()

        # check for SQL error indicators
        if any(tok in body for tok in SQL_ERROR_SIGNS):
            return True

        # simple heuristic: large change in response length vs baseline
        if baseline:
            if abs(len(body) - len(baseline)) > max(80, int(len(baseline) * 0.10)):
                return True

    return False

def test_xss(url: str, param: str) -> bool:
    """
    Basic reflected XSS test:
    - inject a benign script payload and check whether it is reflected verbatim
    - return True for clear reflection (vulnerable)
    """
    payload = "<script>alert('XSS')</script>"
    test_url = _replace_query_param(url, param, payload)
    try:
        resp = _safe_get(test_url)
    except requests.RequestException:
        return False

    body = resp.text
    # direct reflection (not escaped) -> vulnerable
    if payload in body:
        return True

    # some pages show only the inner content (alert('XSS')) or partial reflections
    if "alert('xss')" in body.lower():
        return True

    # encoded reflection (e.g. &lt;script&gt;) usually means not directly exploitable reflected XSS
    return False
